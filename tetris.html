<style>
    #tetris {
        width: 240px;
        height: 400px;
        background-color: #000;
        border: 4px solid #333;
        position: relative;
    }

    .tetromino {
        width: 24px;
        height: 24px;
        border: 1px solid #555;
        position: absolute;
    }

    .mini-grid {
        width: 80px;
        height: 80px;
        border: 2px solid #333;
        display: flex;
        flex-wrap: wrap;
        margin-top: 20px;
    }

    .mini-grid div {
        width: 20px;
        height: 20px;
        border: 1px solid #555;
        box-sizing: border-box;
        background-color: #111;
    }

    #score {
        margin-top: 20px;
        font-size: 20px;
        color: #fff;
    }

    #start-button {
        display: block;
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 16px;
        background-color: #333;
        color: #fff;
        border: none;
        cursor: pointer;
    }
</style>

<div id="tetris"></div>
<div class="mini-grid">
    <div></div><div></div><div></div><div></div>
    <div></div><div></div><div></div><div></div>
    <div></div><div></div><div></div><div></div>
    <div></div><div></div><div></div><div></div>
</div>
<div id="score">0</div>
<button id="start-button">Start/Pause</button>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        const grid = document.getElementById("tetris");
        let squares = Array.from(grid.querySelectorAll("div"));
        const scoreDisplay = document.getElementById("score");
        const startButton = document.getElementById("start-button");

        const width = 10;
        let currentPosition = 4;
        let currentRotation = 0;
        let timerId;
        let score = 0;
        const colors = [
            "#000",
            "#f00",
            "#0f0",
            "#00f",
            "#f80",
            "#f0f",
            "#0ff",
            "#ff0"
        ];

        // Tetromino shapes (same as before)
        // ...

        // Function to draw the tetromino on the grid
        function draw() {
            current.forEach((index) => {
                squares[currentPosition + index].classList.add("tetromino");
                squares[currentPosition + index].style.backgroundColor =
                    colors[random + 1];
            });
        }

        // Function to undraw the tetromino from the grid
        function undraw() {
            current.forEach((index) => {
                squares[currentPosition + index].classList.remove("tetromino");
                squares[currentPosition + index].style.backgroundColor = "";
            });
        }

        // Function to move the tetromino down
        function moveDown() {
            undraw();
            currentPosition += width;
            draw();
            freeze();
        }

        // Function to freeze the tetromino if it reaches the bottom or collides with another tetromino
        function freeze() {
            if (
                current.some((index) =>
                    squares[currentPosition + index + width].classList.contains(
                        "taken"
                    )
                )
            ) {
                current.forEach((index) =>
                    squares[currentPosition + index].classList.add("taken")
                );

                // Start a new tetromino falling
                random = nextRandom;
                nextRandom = Math.floor(Math.random() * tetrominos.length);
                current = tetrominos[random][currentRotation];
                currentPosition = 4;
                draw();
                displayShape();
                addScore();
                gameOver();
            }
        }

        // Function to move the tetromino left, unless it is at the edge or there is a blockage
        function moveLeft() {
            undraw();
            const isAtLeftEdge = current.some(
                (index) => (currentPosition + index) % width === 0
            );

            if (!isAtLeftEdge) currentPosition -= 1;

            if (
                current.some((index) =>
                    squares[currentPosition + index].classList.contains("taken")
                )
            ) {
                currentPosition += 1;
            }

            draw();
        }

        // Function to move the tetromino right, unless it is at the edge or there is a blockage
        function moveRight() {
            undraw();
            const isAtRightEdge = current.some(
                (index) => (currentPosition + index) % width === width - 1
            );

            if (!isAtRightEdge) currentPosition += 1;

            if (
                current.some((index) =>
                    squares[currentPosition + index].classList.contains("taken")
                )
            ) {
                currentPosition -= 1;
            }

            draw();
        }

        // Function to rotate the tetromino
        function rotate() {
            undraw();
            currentRotation++;
            if (currentRotation === current.length) {
                currentRotation = 0;
            }
            current = tetrominos[random][currentRotation];
            draw();
        }

        // Function to display the next tetromino in the mini-grid display
        const displaySquares = document.querySelectorAll(".mini-grid div");
        const displayWidth = 4;
        const displayIndex = 0;

        // Function to display the next tetromino
        function displayShape() {
            displaySquares.forEach((square) => {
                square.classList.remove("tetromino");
                square.style.backgroundColor = "";
            });
            upNextTetrominos[nextRandom].forEach((index) => {
                displaySquares[displayIndex + index].classList.add("tetromino");
                displaySquares[displayIndex + index].style.backgroundColor =
                    colors[nextRandom + 1];
            });
        }

        // Add event listeners for key presses
        document.addEventListener("keydown", control);

        // Function to handle key presses
        function control(event) {
            if (event.keyCode === 37) {
                moveLeft();
            } else if (event.keyCode === 38) {
                rotate();
            } else if (event.keyCode === 39) {
                moveRight();
            } else if (event.keyCode === 40) {
                moveDown();
            }
        }

        // Function to add score for each row cleared
        function addScore() {
            for (let i = 0; i < 199; i += width) {
                const row = [
                    i,
                    i + 1,
                    i + 2,
                    i + 3,
                    i + 4,
                    i + 5,
                    i + 6,
                    i + 7,
                    i + 8,
                    i + 9
                ];

                if (row.every((index) => squares[index].classList.contains("taken"))) {
                    score += 10;
                    scoreDisplay.innerHTML = score;
                    row.forEach((index) => {
                        squares[index].classList.remove("taken");
                        squares[index].classList.remove("tetromino");
                        squares[index].style.backgroundColor = "";
                    });
                    const squaresRemoved = squares.splice(i, width);
                    squares = squaresRemoved.concat(squares);
                    squares.forEach((cell) => grid.appendChild(cell));
                }
            }
        }

        // Function to check if the game is over
        function gameOver() {
            if (
                current.some((index) =>
                    squares[currentPosition + index].classList.contains("taken")
                )
            ) {
                scoreDisplay.innerHTML = "Game Over";
                clearInterval(timerId);
            }
        }

        // Start and pause the game
        startButton.addEventListener("click", () => {
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            } else {
                draw();
                timerId = setInterval(moveDown, 1000);
                nextRandom = Math.floor(Math.random() * tetrominos.length);
                displayShape();
            }
        });
    });
</script>
